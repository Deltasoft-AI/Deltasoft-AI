'use strict';

const randomUseragent = require('random-useragent');
const url = require('url');
const ofetch = require('ofetch');
const fs = require('fs');
const md5 = require('md5');
const path = require('path');
const WebSocket = require('ws');
const PQueue = require('p-queue-compat');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const fs__default = /*#__PURE__*/_interopDefaultCompat(fs);
const md5__default = /*#__PURE__*/_interopDefaultCompat(md5);
const path__default = /*#__PURE__*/_interopDefaultCompat(path);
const WebSocket__default = /*#__PURE__*/_interopDefaultCompat(WebSocket);
const PQueue__default = /*#__PURE__*/_interopDefaultCompat(PQueue);

function extractFormKey(html) {
  const scriptRegex = /<script>if\(.+\)throw new Error;(.+)<\/script>/;
  const scriptText = html.match(scriptRegex)?.[1];
  const keyRegex = /var .="([0-9a-f]+)",/;
  const keyText = scriptText.match(keyRegex)?.[1];
  const cipherRegex = /.\[(\d+)\]=.\[(\d+)\]/g;
  const cipherPairs = Array.from(scriptText.matchAll(cipherRegex));
  const formKeyList = new Array(cipherPairs.length).fill("");
  for (const pair of cipherPairs) {
    const [formKeyIndex, keyIndex] = pair.slice(1).map(Number);
    formKeyList[formKeyIndex] = keyText[keyIndex];
  }
  const formKey = formKeyList.join("");
  return formKey;
}
class Poe {
  constructor(options) {
    this.__urls = {
      request: "https://poe.com/api/gql_POST",
      receive: "https://poe.com/api/receive_POST",
      home: "https://poe.com",
      settings: "https://poe.com/api/settings"
    };
    this.__headers = {
      "User-Agent": randomUseragent.getRandom(),
      Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
      "Accept-Encoding": "gzip, deflate, br",
      "Accept-Language": "en-US,en;q=0.5",
      Dnt: "1",
      Te: "trailers",
      "Upgrade-Insecure-Requests": "1",
      // default
      Referrer: "https://poe.com/",
      Origin: "https://poe.com",
      Host: "poe.com",
      "Sec-Fetch-Dest": "empty",
      "Sec-Fetch-Mode": "cors",
      "Sec-Fetch-Site": "same-origin",
      Connection: "keep-alive"
    };
    this.__ws_domain = `tch${Math.floor(Math.random() * 1e6)}`;
    this.__queries = /* @__PURE__ */ new Map();
    this.__queue = new PQueue__default({ concurrency: 1 });
    this.__queue_count = 0;
    this.__poe_tokens = [];
    this.__queue.on("idle", async () => {
      if (!this.__queue.size) {
        if (options?.purge_conversation?.enable) {
          await this.purge(options?.purge_conversation?.count ?? 50).catch(() => {
          });
        }
        this.__queue_count = 0;
      }
    });
    this.__bot_name = options?.bot_name;
    this.__poe_tokens = options?.tokens ?? [];
    this.load_queries();
  }
  load_queries() {
    const folder_path = path__default.join(path__default.dirname(url.fileURLToPath((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (document.currentScript && document.currentScript.src || new URL('index.cjs', document.baseURI).href)))), "..", "graphql");
    const files = fs__default.readdirSync(folder_path);
    for (const filename of files) {
      const ext = path__default.extname(filename);
      if (ext !== ".graphql")
        continue;
      const query_name = path__default.basename(filename, ext);
      try {
        const query = fs__default.readFileSync(path__default.join(folder_path, filename), "utf-8");
        this.__queries.set(query_name, query);
      } catch (error) {
        console.warn(`Failed to load query '${query_name}': ${error.message}`);
      }
    }
  }
  async init() {
    if (this.__formkey)
      return;
    this.__headers.Cookie = "p-b=" + this.__poe_tokens[0] + "; Domain=poe.com";
    const html = await ofetch.ofetch(this.__urls.home, {
      headers: this.__headers,
      parseResponse: (str) => str
    }).catch(() => null);
    if (!html) {
      delete this.__formkey;
      delete this.__channel_data;
      delete this.__bot;
      const got_ratelimit_token = this.__poe_tokens[0];
      const index = this.__poe_tokens.indexOf(got_ratelimit_token);
      if (index > -1) {
        this.__poe_tokens.splice(index, 1);
        this.__poe_tokens.push(got_ratelimit_token);
      }
      throw new Error("You've got ratelimit.");
    }
    const json_regex = /<script id="__NEXT_DATA__" type="application\/json">(.+?)<\/script>/;
    const json_text = json_regex.exec(html)?.[1] ?? "";
    const next_data = JSON.parse(json_text);
    this.__formkey = extractFormKey(html);
    const available_bots = next_data.props?.pageProps?.payload?.viewer?.availableBots;
    if (!available_bots)
      throw new Error("Invalid token.");
    const settings = await ofetch.ofetch(this.__urls.settings, {
      headers: this.__headers,
      parseResponse: JSON.parse
    });
    this.__channel_data = settings.tchannelData;
    for (const bot of available_bots.filter((bot2) => bot2.deletionState === "not_deleted")) {
      if (bot.displayName.toLocaleLowerCase() === this.__bot_name.toLocaleLowerCase()) {
        const url = `https://poe.com/_next/data/${next_data.buildId}/${bot.displayName}.json`;
        let chat_data;
        while (!chat_data) {
          try {
            const data = await ofetch.ofetch(url, {
              headers: this.__headers,
              parseResponse: JSON.parse
            });
            chat_data = data.pageProps.payload.chatOfBotDisplayName;
            this.__bot = chat_data;
          } catch (error) {
            await new Promise((resolve) => setTimeout(resolve, 5 * 1e3));
          }
        }
        break;
      }
    }
    if (!this.__bot)
      throw new Error("Invalid bot name.");
  }
  async connect_ws() {
    if (!this.__channel_data)
      throw new Error("Channel data is empty.");
    const query = `min_seq=${this.__channel_data.minSeq}&channel=${this.__channel_data.channel}&hash=${this.__channel_data.channelHash}`;
    const url = `wss://${this.__ws_domain}.tch.${this.__channel_data.baseHost}/up/${this.__channel_data.boxName}/updates?${query}`;
    const headers = { "User-Agent": this.__headers["User-Agent"] };
    const ws = new WebSocket__default(url, { headers, rejectUnauthorized: false });
    return new Promise((resolve) => {
      ws.onopen = () => {
        return resolve(ws);
      };
    });
  }
  async disconnect_ws(ws) {
    return new Promise((resolve, reject) => {
      ws.onclose = () => {
        resolve(true);
      };
      try {
        ws.close();
      } catch (error) {
        reject(error);
      }
    });
  }
  async request(queryName, variables, queryDisplayName) {
    const query = this.__queries.get(queryName);
    if (!query)
      throw new Error(`Query '${queryName}' not found.`);
    if (!this.__channel_data)
      throw new Error("Channel data is empty.");
    if (!this.__formkey)
      throw new Error("Formkey is empty.");
    let result;
    const payload = { query, variables };
    if (queryDisplayName)
      payload["queryName"] = queryDisplayName;
    let attempts = 0;
    while (!result) {
      if (attempts === 20)
        throw new Error("Too many attempts.");
      attempts++;
      try {
        const headers = {
          "poe-formkey": this.__formkey ?? "",
          "poe-tchannel": this.__channel_data?.channel ?? "",
          "poe-tag-id": md5__default(JSON.stringify(payload) + this.__formkey + "WpuLMiXEKKE98j56k"),
          ...this.__headers
        };
        const response = await ofetch.ofetch(this.__urls.request, {
          method: "POST",
          body: payload,
          headers
        });
        if (response.data)
          result = response;
        else {
          await new Promise((resolve) => setTimeout(resolve, 5 * 1e3));
        }
      } catch (error) {
        await new Promise((resolve) => setTimeout(resolve, 5 * 1e3));
      }
    }
    return result;
  }
  async ask(prompt, options) {
    const result = await this.__queue.add(async () => {
      this.__queue_count++;
      if (typeof options?.on_idling === "function")
        options.on_idling(this.__queue_count);
      let response = "", ws = void 0, error = void 0;
      try {
        await this.init();
        const timeout = setTimeout(async () => {
          await this.disconnect_ws(ws);
          error = new Error("Got timeout while waiting for bot response.");
        }, 2 * 60 * 1e3);
        ws = await this.connect_ws();
        await this.subscribe();
        this.send_message(prompt);
        response = await this.get_message(ws);
        clearTimeout(timeout);
      } catch (err) {
        error = err?.stack ? err : new Error("Something went wrong while waiting for bot response.");
      } finally {
        if (ws)
          await this.disconnect_ws(ws);
        await new Promise((resolve) => setTimeout(resolve, 2.5 * 1e3));
        if (typeof options?.on_complete === "function")
          options.on_complete(this.__queue_count, response);
        if (error)
          throw error;
        return response;
      }
    });
    return result ?? "";
  }
  async subscribe() {
    await this.request(
      "SubscriptionsMutation",
      {
        subscriptions: [
          {
            subscriptionName: "messageAdded",
            query: this.__queries.get("MessageAddedSubscription")
          },
          {
            subscriptionName: "viewerStateUpdated",
            query: this.__queries.get("ViewerStateUpdatedSubscription")
          },
          {
            subscriptionName: "viewerMessageLimitUpdated",
            query: this.__queries.get("ViewerMessageLimitUpdatedSubscription")
          }
        ]
      },
      "subscriptionsMutation"
    );
  }
  async send_message(prompt) {
    const get_prompt = (conversation) => {
      const prompt_settings = [];
      for (const convo of conversation)
        if (convo.role === "system")
          prompt_settings.push(convo.content.trim());
      conversation = conversation.filter((convo) => convo.role !== "system");
      const latest = conversation.filter((convo) => convo.role === "user").pop();
      if (latest)
        conversation = conversation.filter((convo) => convo !== latest);
      prompt = "";
      prompt += "**Prompt Settings**:\n\n";
      prompt += prompt_settings.join("\n\n") + "\n\n";
      prompt = prompt.trim();
      prompt += "\n\n**Conversation History**:\n\n";
      for (let convo of conversation) {
        switch (convo?.role) {
          case "model":
            if (!convo?.name)
              convo.name = this.__bot_name;
            prompt += `[${convo.name} - AI Model]: ${convo?.content ? convo.content.trim() : "No message"}

`;
            break;
          case "user":
            if (!convo?.name)
              convo.name = "Unnamed";
            prompt += `[${convo.name} - User]: ${convo?.content ? convo.content.trim() : "No message"}

`;
            break;
        }
      }
      prompt = prompt.trim();
      prompt += "\n\n**Latest User Message**:\n\n";
      if (latest)
        prompt += `${latest.content ? latest.content.trim() : "No message"}

`;
      prompt = prompt.trim();
      prompt += "\n\n**Latest AI Model Response**:";
      return prompt.trim();
    };
    return new Promise((resolve, reject) => {
      this.request("AddHumanMessageMutation", {
        bot: this.__bot?.defaultBotObject.nickname,
        query: typeof prompt === "object" ? get_prompt(prompt) : prompt,
        chatId: this.__bot?.chatId,
        source: null,
        withChatBreak: false
      }).then((message_data) => {
        if (!message_data.data?.messageCreateWithStatus?.messageLimit?.canSend)
          reject(new Error("Cannot send."));
        resolve(true);
      }).catch((error) => {
        reject(error);
      });
    });
  }
  async get_message(ws) {
    return new Promise((resolve, reject) => {
      ws.onmessage = (e) => {
        const data = JSON.parse(e.data.toString());
        if (!Array.isArray(data.messages))
          return;
        for (const message_str of data.messages) {
          const message_data = JSON.parse(message_str);
          if (message_data.message_type !== "subscriptionUpdate")
            continue;
          const message = message_data.payload?.data?.messageAdded;
          if (message?.author !== "human" && message?.state === "complete") {
            return resolve(message.text);
          }
        }
      };
      ws.onclose = () => {
        reject(new Error("You've reached the timeout, your request has been dismissed."));
      };
    });
  }
  async history(count = 25, cursor = null) {
    await this.init();
    try {
      const result = await this.request("ChatListPaginationQuery", {
        count,
        cursor,
        id: this.__bot?.id
      });
      const messages = result?.data?.node?.messagesConnection?.edges;
      if (!messages)
        throw new Error("No messages found in result");
      return messages;
    } catch (error) {
      return null;
    }
  }
  async delete(...message_ids) {
    await this.init();
    try {
      const ids = message_ids.flat().map((id) => parseInt(String(id))).filter((id) => !isNaN(id));
      if (ids.length === 0)
        return null;
      const result = await this.request("DeleteMessageMutation", {
        messageIds: ids
      });
      return result;
    } catch (error) {
      return null;
    }
  }
  async purge(count = -1) {
    try {
      let last_messages = (await this.history(50)).reverse();
      while (last_messages.length) {
        const message_ids = [];
        for (const message of last_messages) {
          if (count === 0)
            break;
          count--;
          const message_id = message?.node?.messageId;
          if (message_id)
            message_ids.push(parseInt(message_id));
        }
        await this.delete(message_ids);
        if (count === 0) {
          return;
        }
        last_messages = (await this.history(50)).reverse();
      }
      return;
    } catch (error) {
      return;
    }
  }
}

exports.Poe = Poe;
